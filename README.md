# mobile Artifact Subspace Reconstruction (mASR)

ASR is a statistical artifact correction method. It detects artifacts
based on their abnormal statistical properties when compared to
artifact-free data. After detection, a correction is applied and the
result of the method are data with the same amount of samples and
channels as the (possibly corrupted) input data. 

However, because ASR is implemented in Matlab, in its current
implementation, ASR cannot be used in mobile EEG recordings easily. 
Matlab needs a decently powerful PC and is only available for operating
systems running on an Intel-architecture processor. Mobile recording
hardware is typically not fast enough to run Matlab and usually sports
some variation of ARM architecture. There have been efforts to modify
ASR for mobile devices, but they aim mainly at field
programmable gate arrays (FPGAs), which are more specialised and harder
to use for the average scientist, and there is no open source
implementation of mobile ASR as of yet.

Therefore we propose mobile ASR (mASR), an implementation of ASR for
limited hardware, in our case a research platform to evaluate audio/time
domain/hearing aid signal processing.

This repository provides mobile ASR (mASR) as an openMHA plugin.

# Implementation and architecture

#### mASR in the openMHA framework

Our implementation consists of several files, of which the most
important are:

codegen

:   contains the C++ code generated by the Matlab coder, including the
    so-called entry-point functions `asr_calibrate` and `asr_process`,
    which are the equivalent of the Matlab functions of the same name.

Makefile

:   The Makefile providing build automation.

asr_calibrate_simple.m

:   The simplified version of the asr_calibrate.m script.

asr_process_simple.m

:   is the simplified version of asr_process.m

make.m

:   steers the Matlab Coder configuration.

asr.cpp

:   contains the implementation of the openMHA plugin

Our plugin implementation follows the usual structure of openMHA plugins
and implements the usual openMHA callback functions. The incoming EEG
signal is provided via AC variable, the usual inter-plugin communication
method in openMHA. The `stride` attribute of the AC variable represents
the number of channels in the EEG signal, which has the same
requirements as the input signal of the reference implementation. To
import the signal into openMHA, other plugins have to be used, for
example the `lsl2ac`-plugin, which converts LSL streams
into AC variables. The most important functions are the `prepare()`, the
`process()`, and the `release()` functions. The `prepare()` function is
where most initialization takes place and the configuration variables
are locked in. It also performs the calibration. The calibration is
provided as csv file, where every row presents a channel. `process()` is
the main processing function. It is called periodically by the audio
processing thread of the openMHA executable. To ensure real-time safety,
the actual artifact reduction happens in a separate thread. The input
data is shared between the threads safely by means of a lock-free
first-in, first-out (FIFO) buffer. The output of the cleaning algorithm
is then shared with the processing thread via another FIFO buffer and
made accessible to the downstream plugins as an AC variable. The output
AC variable can then processed within openMHA or be exported and
processed elsewhere, e.g. via the `ac2lsl` plugin. `release()` signals
the ASR thread to terminate and unlocks the configuration variables. The
plugin has the following configuration variables:

SamplingRate

:   the nominal sampling rate of the input data in Hz.

WindowLength

:   Length of the statistics window, in seconds (e.g., 0.5). This should
    not be much longer than the time scale over which artifacts persist,
    but the number of sample in the window should not be smaller than
    1.5x the number of channels.

VarName

:   Name of the input AC variable.

CalibrationFileName

:   file name of the calibration file.

#### Translation of ASR to Matlab Coder-compatible source base

In order to be able to generate C/C++ code from the ASR Matlab codebase,
some steps with regards to compatibility to the Matlab code generation
needed to be implemented. Firstly, all unsupported functions were
replaced (complete list of supported functions:
<https://de.mathworks.com/help/referencelist.html>. This included the
unrolling of the `bsxfun` function into explicit loops
(<https://de.mathworks.com/help/matlab/ref/bsxfun.html>). `bsxfun`
allows to apply element-wise operations by providing a function and an
array, `bsxfun` implicitly expands the application to all elements and
the resulting operation can be equivalently expressed by looping through
the array. Another example is slicing of vectors or array sections,
which the Matlab Coder cannot expand to all datatypes automatically.
Instead, an explicit indexing was implemented at the corresponding code
locations. Then, all variables were declared with their desired size and
initialized before their first usage in both `asr_calibrate.m` and
`asr_process.m`. Subsequently tests were performed to ensure the
equivalency of the adapted ASR code to the original code base.

# System requirements
This manual assumes openMHA is installed via package manager or installer package on an x86 Ubuntu or macOS system. 
Self-compiled openMHA distributions should work but may require adaptations of the include paths in the Makefile.
mASR was tested with openMHA 4.16.0 and openMHA 4.17.0 and Matlab R2022a with the Matlab Coder module.

Compiling requires a C++ compiler compatible with the installed openMHA distribution (if not self-compiled). Benchmarking and unit testing requires google benchmark and 
googletest.

# Installation
On Ubuntu, if openMHA was installed via package manager, use the Debian packages from the most current release (See "Releases"-tab in the GitHub-repository).
For other operating systems mASR needs to be compiled manually.

# Compilation

In order to compile the plugin, type
 ```make```
in a shell. The resulting shared library should be copied into the openMHA plugin directory (usually /usr/local/lib on Linux systems) or added to the LD_LIBRARY_PATH environment variable

# Quality control

In order to ensure that mASR works correctly, we processed data sets
using the reference implementation and our implementation and then
compared the results of `asr_calibrate_simple()` and its C++-counterpart
and `asr_process_simple()` and its C++-counterpart. We deem the test for
`asr_process_simple()` passed when all outputs of the calibration and
processing have the same value as the output of the reference
implementation, up to a relative tolerance of $10^-5$. Test data adapted
from a publicly available data set are included in the
mASR distribution on GitHub. In order to run the tests, the user needs
to run

    make test; ./test

within the main repository directory.
